---
import NavBar from "../../components/NavBar.astro";
import '../../styles/global.css'
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content="Astro description" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<link rel="stylesheet" href="../styles/global.css" />
		<title>Project Page</title>
	</head>
	<body>
		<NavBar></NavBar>
		<div class="content">
			<h1 class="title">Project a Month Website</h1>
			<p class="description">The website I'll be using to display all my projects in 2024</p>
			<img src="/website.png" alt="Project Image" class="image"/>
			<div class="tech-stack">
				<h2 class="tech-stack-title">Tech Stack:</h2>
				<div class="tech-stack-list">
					<span class="tech-item">Astro</span>
					<span class="tech-item">TypeScript</span>
					<span class="tech-item">TailwindCSS</span>
					<!-- Add more tech items as needed -->
				</div>
			</div>
			<hr class="line"/>
			<p class="basic-text">I choose astro to make this website in mainly due to its performance. It strips out unused JS and only uses what it needs to. This makes it ideal for primarily static sites (like this one). Also, it offers incredibly flexibility: you can use components from any framework you want, be it React, Vue, Angular, Svelete, or even all of them at the same time, if you want. </p>
			<img src="/website/performance.png" alt="Project Image" class="basic-image"/>
			<p class="basic-text">I actually did not use any other framework besides Astro to make this site in, though. Originally, I was planning on using React components, and only have one main index.astro page written in Astro, but as far as I can tell an Astro file can do everything a .tsx can (at least when it comes to content/styling). I actually created the NavBar component initially in React, before rewriting it in Astro literally just to see if I could.  </p>
			<img src="/website/reactnav.png" alt="Project Image" class="basic-image"/>
			<img src="/website/astronav.png" alt="Project Image" class="basic-image"/>
			<p class="basic-text">When it comes to the file structure of this website, I tried my best to follow the industry standard style of splitting up reusable elements into components and putting all of those in a folder, then having a "pages" folder where the actual content/components would go. I also have a "projects" folder that will eventually contain exactly 12 files: the corresponding breakdown page of each project, for each month. Right now you're viewing src/pages/projects/website.astro. </p>
			<p class="basic-text">If noticed something off about the way I structured the project, you're not alone; there's actually a better way to structure the pages, specifically the project pages, so that instead of 12 seperate pages for each project, there's only 1. The way you would do it would be to create one singular page component containing the blueprint of the structure and styling, and then pass the project-specific props into it. Like for example, a title prop, description, image, tech stack, and then a series of 'p' and 'img' tags. This works because all these project pages follow the same structure. Now to be honest I'm not entirely sure it would work, but I think it would because I did something similar for the project card component.  </p>
			<img src="/website/props.png" alt="Project Image" class="basic-image"/>
			<p class="basic-text">There's only 1 ProjectCard file, not 12. So theoretically, following the same principle, I should be able to have it so that there's only 1 ProjectPage, not 12. The only thing is, the project pages will most likely have a different number of 'img' and 'p' tags, and in a different order, so the pages follow the same general structure, not the same exact structure. One idea for getting around this would be to pass an array of content blocks as a prop, where each block defines the type (paragraph, image, etc.) and its content, then iterate over the blocks and render each block based on its type. I'll most likely attempt to refactor the project pages in this way later on. </p>
		</div>
	</body>
</html>





<style>


.title {
	  color: #C2BAC1; 
      font-weight: bold; 
      text-align: left;
      font-size: 3em;
      padding: 10px;
	  margin-top: 6vw;
	  margin-left: 6vw;
	}

	.description {
	  color: #C2BAC1; 
	  font-weight: bold;
      text-align: left;
      font-size: 1.2em;
      padding: 20px;
	  margin-left: 6vw;
	}

	.image {
	  border-radius: 10px;
	  display: block;
	  margin-left: auto;
	  margin-right: auto;
	  margin-bottom: 3vw; 
	  width: 50%;
	  height: auto;
	}

	.tech-stack {
	  display: flex;
	  align-items: center; 
	  font-size: 1.2em;
	  padding: 10px;
	  margin-left: 6vw; 
	  margin-bottom: 3vw; 
	}

	.tech-stack-list {
		display: flex;
  		flex-wrap: wrap; /* Allow items to wrap */
 	 	gap: 10px; /* Provide space between items */
	}

	.tech-item {
		margin-right: 10px;
		color: #C2BAC1; 
		background-color: transparent;
		border: 2px solid pink;
		border-radius: 50px;
		padding: 5px 15px;
	}

	.tech-stack-title {
	  margin-right: 10px;
	  color: #C2BAC1; 
	  font-weight:bold;
	  font-size: 1.2em;
	}

	.line {
		width: 85%; /* Adjust to your preference */
		border: 0;
		height: 2px;
		background: #486C88; 
		margin: 0 auto; /* Center the line */
		margin-bottom: 3vw; 
	}

	.basic-text {
		font-size: 1.2em; 
		color: #C2BAC1; 
		margin-left: 8vw; 
		margin-right: 8vw; 
		margin-bottom: 3vw; 
	}

	.basic-image {
	  border-radius: 10px;
	  margin-left: auto;
	  margin-right: auto;
	  margin-bottom: 3vw; 
	  width: 75%;
	}

	@media screen and (max-width: 700px) {
    .tech-stack {
      font-size: 1em; 
    }
  }

html {
		scroll-behavior: smooth;
	}
	body {
		background-color: #294F6D;
	}
	
	body::-webkit-scrollbar {
	width: 10px; 
	}

	body::-webkit-scrollbar-track {
	background: #294F6D;
	}

	body::-webkit-scrollbar-thumb {
	background: rgb(119, 156, 171); 
	border-radius: 20px;
	}

	body::-webkit-scrollbar-thumb:hover {
	background: rgb(119, 170, 171); 
	}
    
</style>